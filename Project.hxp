package;

import hxp.*;
import lime.tools.*;


import sys.FileSystem;
import sys.io.File;
import haxe.io.Bytes;
import haxe.io.Path;
import haxe.ds.Map;
import haxe.xml.Printer;

using StringTools;

class Project extends HXProject
{
	public var librarys:Array<Array<Dynamic>>;

	public function new()
	{
		super();

		librarys = [
			['flixel', ''],
			['flixel-addons', ''],
			['flixel-ui', ''],
			['lime', ''],
			['openfl', ''],
			['hscript', ''],
			['hxcpp', '', isWindows()],
			['hxcpp-debug-server', '', isDebug() && isWindows()],];

		for (lib in librarys)
			if (lib[2] ?? true)
				haxelibs.push(new Haxelib(lib[0], lib[1]));

		sources.push("source");

		appConfig();
		featureFlagConfig();
		setHaxedefs();
		configureOutputDir();
		configureAssets();
		configureIcons();
	}

	public var metaInfo:Map<String, String> = [
		"title" => "Friday Night Funkin' Vs Macohi",
		"version" => "0.1.0",
		"packageName" => "com.macohi.vsmacohi",
		"company" => "Macohi",
	];

	public var appInfo:Map<String, String> = [
		"main_class" => "Main",
		"exe" => "vsMacohi",
		"preloader" => "flixel.system.FlxPreloader",
	];

	public function appConfig()
	{
		this.meta.title = metaInfo.get('title');
		this.meta.version = metaInfo.get('version');
		this.meta.packageName = metaInfo.get('packageName');
		this.meta.company = metaInfo.get('company');

		this.app.main = appInfo.get('main_class');
		this.app.file = appInfo.get('exe');
		this.app.preloader = appInfo.get('preloader');

		this.sources.push('source');

		this.window.fps = 60;

		this.window.width = 1280;
		this.window.height = 720;

		this.window.background = 0xFF000000;

		this.window.hardware = true;
		this.window.vsync = false;

		if (isWeb())
		{
			this.window.resizable = true;
		}

		if (isDesktop())
		{
			this.window.orientation = Orientation.LANDSCAPE;
			this.window.fullscreen = false;
			this.window.resizable = true;
			this.window.vsync = false;
		}

		if (isMobile())
		{
			this.window.orientation = Orientation.LANDSCAPE;
			this.window.fullscreen = false;
			this.window.resizable = false;
			this.window.width = 0;
			this.window.height = 0;
		}
	}

	public var PRELOAD_ALL:FeatureFlag = "PRELOAD_ALL";
	public var EMBED_ASSETS:FeatureFlag = "EMBED_ASSETS";

	public function featureFlagConfig()
	{
		PRELOAD_ALL.apply(this, true);
		EMBED_ASSETS.apply(this, false);
	}

	public function setHaxedefs()
	{
		// Enable OpenFL's error handler. Required for the crash logger.
		// setHaxedef("openfl-enable-handle-error");

		// Enable stack trace tracking. Good for debugging but has a (minor) performance impact.
		setHaxedef("HXCPP_CHECK_POINTER");
		setHaxedef("HXCPP_STACK_LINE");
		setHaxedef("HXCPP_STACK_TRACE");
		setHaxedef("hscriptPos");

		// setHaxedef("safeMode");

		// If we aren't using the Flixel debugger, strip it out.
		if (isRelease())
			setHaxedef("FLX_NO_DEBUG");

		// Disable the built in pause screen when unfocusing the game.
		setHaxedef("FLX_NO_FOCUS_LOST_SCREEN");

		if (isRelease())
		{
			// Improve performance on Nape
			// TODO: Do we even use Nape?
			setHaxedef("NAPE_RELEASE_BUILD");
		}

		// Cleaner looking compiler errors.
		setHaxedef("message.reporting", "pretty");
	}

	function configureOutputDir()
	{
		// Set the output directory. Depends on the target platform and build type.

		var buildDir = 'export/${isDebug() ? 'debug' : 'release'}/';

		info('Output directory: $buildDir');
		app.path = buildDir;
	}

	static final EXCLUDE_ASSETS:Array<String> = [];
	static final EXCLUDE_ASSETS_WEB:Array<String> = ["*.ogg"];
	static final EXCLUDE_ASSETS_NATIVE:Array<String> = ["*.mp3"];

	function configureAssets()
	{
		var exclude = EXCLUDE_ASSETS.concat(isWeb() ? EXCLUDE_ASSETS_WEB : EXCLUDE_ASSETS_NATIVE);
		var shouldPreload = PRELOAD_ALL.isEnabled(this);
		var shouldEmbed = EMBED_ASSETS.isEnabled(this);

		if (shouldEmbed)
			info('Embedding assets into executable...');
		else
			info('Including assets alongside executable...');

		// Default asset library
		var shouldPreloadDefault = true;
		addAssetLibrary("default", shouldEmbed, shouldPreloadDefault);

		var pathsToAdd = ['assets/data', 'assets/fonts', 'assets/images', 'assets/music', 'assets/sounds',];
		for (path in pathsToAdd)
			addAssetPath(pathsToAdd, pathsToAdd, "default", ["*"], exclude, shouldEmbed);

		// Art asset library (where README and CHANGELOG pull from)
		var shouldEmbedArt = false;
		addAsset("LICENSE.md", "LICENSE.md", "art", shouldEmbedArt);
		addAsset("CHANGELOG.md", "CHANGELOG.md", "art", shouldEmbedArt);
	}

	/**
	 * Configure the application's favicon and executable icon.
	 */
	function configureIcons()
	{
		addIcon("assets/images/appicons/icon16.png", 16);
		addIcon("assets/images/appicons/icon32.png", 32);
		addIcon("assets/images/appicons/icon64.png", 64);
		addIcon("assets/images/appicons/iconOG.png");
	}

	//
	// HELPER FUNCTIONS
	// Easy functions to make the code more readable.
	//

	public function isWeb():Bool
	{
		return this.platformType == PlatformType.WEB;
	}

	public function isMobile():Bool
	{
		return this.platformType == PlatformType.MOBILE;
	}

	public function isDesktop():Bool
	{
		return this.platformType == PlatformType.DESKTOP;
	}

	public function isConsole():Bool
	{
		return this.platformType == PlatformType.CONSOLE;
	}

	public function is32Bit():Bool
	{
		return this.architectures.contains(Architecture.X86);
	}

	public function is64Bit():Bool
	{
		return this.architectures.contains(Architecture.X64);
	}

	public function isWindowsHost():Bool
	{
		return System.hostPlatform == WINDOWS;
	}

	public function isMacHost():Bool
	{
		return System.hostPlatform == MAC;
	}

	public function isLinuxHost():Bool
	{
		return System.hostPlatform == LINUX;
	}

	public function isWindows():Bool
	{
		return this.target == Platform.WINDOWS;
	}

	public function isMac():Bool
	{
		return this.target == Platform.MAC;
	}

	public function isLinux():Bool
	{
		return this.target == Platform.LINUX;
	}

	public function isAndroid():Bool
	{
		return this.target == Platform.ANDROID;
	}

	public function isIOS():Bool
	{
		return this.target == Platform.IOS;
	}

	public function isIOSSimulator():Bool
	{
		return this.target == Platform.IOS && this.targetFlags.exists("simulator");
	}

	public function isHashLink():Bool
	{
		return this.targetFlags.exists("hl");
	}

	public function isNeko():Bool
	{
		return this.targetFlags.exists("neko");
	}

	public function isJava():Bool
	{
		return this.targetFlags.exists("java");
	}

	public function isNodeJS():Bool
	{
		return this.targetFlags.exists("nodejs");
	}

	public function isCSharp():Bool
	{
		return this.targetFlags.exists("cs");
	}

	public function isDisplay():Bool
	{
		return this.command == "display";
	}

	public function isClean():Bool
	{
		return this.command == "clean";
	}

	public function isDebug():Bool
	{
		return this.debug;
	}

	public function isRelease():Bool
	{
		return !isDebug();
	}

	public function isBundle():Bool
	{
		return this.targetFlags.exists("bundle") && isAndroid();
	}

	public function getHaxedef(name:String):Null<Dynamic>
	{
		return this.haxedefs.get(name);
	}

	public function setHaxedef(name:String, ?value:String):Void
	{
		if (value == null)
			value = "";

		this.haxedefs.set(name, value);
	}

	public function unsetHaxedef(name:String):Void
	{
		this.haxedefs.remove(name);
	}

	public function getDefine(name:String):Null<Dynamic>
	{
		return this.defines.get(name);
	}

	public function hasDefine(name:String):Bool
	{
		return this.defines.exists(name);
	}

	/**
	 * Add a library to the list of dependencies for the project.
	 * @param name The name of the library to add.
	 * @param version The version of the library to add. Optional.
	 */
	public function addHaxelib(name:String, version:String = ""):Void
	{
		this.haxelibs.push(new Haxelib(name, version));
	}

	/**
	 * Add a `haxeflag` to the project.
	 */
	public function addHaxeFlag(value:String):Void
	{
		this.haxeflags.push(value);
	}

	/**
	 * Call a Haxe build macro.
	 */
	public function addHaxeMacro(value:String):Void
	{
		addHaxeFlag('--macro ${value}');
	}

	/**
	 * Add an icon to the project.
	 * @param icon The path to the icon.
	 * @param size The size of the icon. Optional.
	 */
	public function addIcon(icon:String, ?size:Int):Void
	{
		this.icons.push(new Icon(icon, size));
	}

	/**
	 * Add an asset to the game build.
	 * @param path The path the asset is located at.
	 * @param rename The path the asset should be placed.
	 * @param library The asset library to add the asset to. `null` = "default"
	 * @param embed Whether to embed the asset in the executable.
	 * @param padName The name of the Play Assets Delivery that this asset will be added to. (Android only)
	 */
	public function addAsset(path:String, ?rename:String, ?library:String, embed:Bool = false,):Void
	{
		var asset = new Asset(path, rename, null, embed, true);
		@:nullSafety(Off)
		{
			asset.library = library ?? "default";
		}

		/*
		if (padName != null && isBundle())
		{
			asset.deliveryPackName = padName;
		}
			*/

		this.assets.push(asset);
	}

	/**
	 * Add an entire path of assets to the game build.
	 * @param path The path the assets are located at.
	 * @param rename The path the assets should be placed.
	 * @param library The asset library to add the assets to. `null` = "default"
	 * @param include An optional array to include specific asset names.
	 * @param exclude An optional array to exclude specific asset names.
	 * @param embed Whether to embed the assets in the executable.
	 * @param padName The name of the Play Assets Delivery that this asset path will be added to. (Android only)
	 */
	public function addAssetPath(path:String, ?rename:String, library:String, ?include:Array<String>, ?exclude:Array<String>, embed:Bool = false,
			?padName:String):Void
	{
		// Argument parsing.
		if (path == "")
			return;

		if (include == null)
			include = [];

		if (exclude == null)
			exclude = [];

		var targetPath = rename ?? path;
		if (targetPath != "")
			targetPath += "/";

		// Validate path.
		if (!sys.FileSystem.exists(path))
		{
			error('Could not find asset path "${path}".');
		}
		else if (!sys.FileSystem.isDirectory(path))
		{
			error('Could not parse asset path "${path}", expected a directory.');
		}
		else
		{
			// info('  Found asset path "${path}".');
		}

		for (file in sys.FileSystem.readDirectory(path))
		{
			if (sys.FileSystem.isDirectory('${path}/${file}'))
			{
				// Attempt to recursively add all assets in the directory.
				if (this.filter(file, ["*"], exclude))
				{
					addAssetPath('${path}/${file}', '${targetPath}${file}', library, include, exclude, embed, padName);
				}
			}
			else
			{
				if (this.filter(file, include, exclude))
				{
					addAsset('${path}/${file}', '${targetPath}${file}', library, embed, padName);
				}
			}
		}
	}

	/**
	 * Add an asset library to the game build.
	 * @param name The name of the library.
	 * @param embed
	 * @param preload
	 */
	public function addAssetLibrary(name:String, embed:Bool = false, preload:Bool = false):Void
	{
		// sourcePath, name, type, embed, preload, generate, prefix
		var sourcePath = '';
		this.libraries.push(new Library(sourcePath, name, null, embed, preload, false, ""));
	}

	//
	// LOGGING FUNCTIONS
	//

	/**
	 * Display an error message. This should stop the build process.
	 */
	public function error(message:String):Void
	{
		Sys.stderr().write(Bytes.ofString('[ERROR] ${message}'));
		Sys.exit(1);
	}

	/**
	 * Display an info message. This should not interfere with the build process.
	 */
	public function info(message:String):Void
	{
		if (!(isDisplay() || isClean()))
		{
			Sys.println('[INFO] ${message}');
		}
	}
}

/**
	* An object representing a feature flag, which can be enabled or disabled.
	* Includes features such as automatic generation of compile defines and inversion.

	Obviously yoinked from fnf
 */
abstract FeatureFlag(String)
{
	static final INVERSE_PREFIX:String = "NO_";

	public function new(input:String)
	{
		this = input;
	}

	@:from
	public static function fromString(input:String):FeatureFlag
	{
		return new FeatureFlag(input);
	}

	/**
	 * Enable/disable a feature flag if it is unset, and handle the inverse flag.
	 * Doesn't override a feature flag that was set explicitly.
	 * @param enableByDefault Whether to enable this feature flag if it is unset.
	 */
	public function apply(project:Project, enableByDefault:Bool = false):Void
	{
		// TODO: Name this function better?

		if (isEnabled(project))
		{
			// If this flag was already enabled, disable the inverse.
			project.info('Enabling feature flag ${this}');
			getInverse().disable(project, false);
		}
		else if (getInverse().isEnabled(project))
		{
			// If the inverse flag was already enabled, disable this flag.
			project.info('Disabling feature flag ${this}');
			disable(project, false);
		}
		else
		{
			if (enableByDefault)
			{
				// Enable this flag if it was unset, and disable the inverse.
				project.info('Enabling feature flag ${this}');
				enable(project, true);
			}
			else
			{
				// Disable this flag if it was unset, and enable the inverse.
				project.info('Disabling feature flag ${this}');
				disable(project, true);
			}
		}
	}

	/**
	 * Enable this feature flag by setting the appropriate compile define.
	 *
	 * @param project The project to modify.
	 * @param andInverse Also disable the feature flag's inverse.
	 */
	public function enable(project:Project, andInverse:Bool = true)
	{
		project.setHaxedef(this, "");
		if (andInverse)
		{
			getInverse().disable(project, false);
		}
	}

	/**
	 * Disable this feature flag by removing the appropriate compile define.
	 *
	 * @param project The project to modify.
	 * @param andInverse Also enable the feature flag's inverse.
	 */
	public function disable(project:Project, andInverse:Bool = true)
	{
		project.unsetHaxedef(this);
		if (andInverse)
		{
			getInverse().enable(project, false);
		}
	}

	/**
	 * Query if this feature flag is enabled.
	 * @param project The project to query.
	 */
	public function isEnabled(project:Project):Bool
	{
		// Check both Haxedefs and Defines for this flag.
		return project.haxedefs.exists(this) || project.defines.exists(this);
	}

	/**
	 * Query if this feature flag's inverse is enabled.
	 */
	public function isDisabled(project:Project):Bool
	{
		return getInverse().isEnabled(project);
	}

	/**
	 * Return the inverse of this feature flag.
	 * @return A new feature flag that is the inverse of this one.
	 */
	public function getInverse():FeatureFlag
	{
		if (this.startsWith(INVERSE_PREFIX))
		{
			return this.substring(INVERSE_PREFIX.length);
		}
		return INVERSE_PREFIX + this;
	}
}
